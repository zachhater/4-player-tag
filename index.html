<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>4 Player Tag Game</title>
  <style>
    body { margin: 0; background: #222; }
    canvas { background: #87ceeb; display: block; margin: auto; }
  </style>
</head>
<body>
<canvas id="game" width="1200" height="700"></canvas>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

const gravity = 0.7;
const groundLevel = canvas.height - 50;

class Platform {
  constructor(x, y, width, height) {
    this.x = x; this.y = y;
    this.width = width;
    this.height = height;
  }
  draw(ctx) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(this.x, this.y, this.width, this.height);
  }
}

class Player {
  constructor(color, x, keys, abilityName) {
    this.color = color;
    this.x = x; this.y = groundLevel - 60;
    this.width = 40; this.height = 60;
    this.vx = 0; this.vy = 0;
    this.speed = 4;
    this.jumpPower = 15;
    this.canDoubleJump = true;
    this.isOnGround = false;
    this.isIt = false;
    this.keys = keys;
    this.abilityName = abilityName;
    this.abilityCooldown = 0;
    this.abilityActive = false;
    this.abilityDuration = 0;
    this.shield = false;
    this.speedBoost = false;
  }

  moveLeft() { this.vx = -this.speed * (this.speedBoost ? 1.5 : 1); }
  moveRight() { this.vx = this.speed * (this.speedBoost ? 1.5 : 1); }
  stopX() { this.vx = 0; }

  jump() {
    if (this.isOnGround) {
      this.vy = -this.jumpPower;
      this.canDoubleJump = true;
      this.isOnGround = false;
    } else if (this.canDoubleJump) {
      this.vy = -this.jumpPower;
      this.canDoubleJump = false;
    }
  }

  useAbility() {
    if (this.abilityCooldown > 0) return;
    switch (this.abilityName) {
      case 'dash':
        this.vx = (this.vx >= 0 ? 1 : -1) * 30; // Red gets BIG dash
        this.abilityCooldown = 120;
        break;
      case 'shield':
        this.shield = true;
        this.abilityActive = true;
        this.abilityDuration = 180;
        this.abilityCooldown = 300;
        break;
      case 'speed':
        this.speedBoost = true;
        this.abilityActive = true;
        this.abilityDuration = 180;
        this.abilityCooldown = 300;
        break;
      case 'teleport':
        if (this.isOnGround) {
          const dist = (Math.random() < 0.5 ? -1 : 1) * 200;
          this.x = Math.max(0, Math.min(this.x + dist, canvas.width - this.width));
          this.abilityCooldown = 180;
        }
        break;
    }
  }

  update(platforms) {
    this.x += this.vx;
    this.y += this.vy;

    let onAnyPlatform = false;
    for (let plat of platforms) {
      if (this.y + this.height <= plat.y &&
          this.y + this.height + this.vy >= plat.y &&
          this.x + this.width > plat.x &&
          this.x < plat.x + plat.width) {
        this.y = plat.y - this.height;
        this.vy = 0;
        this.isOnGround = true;
        this.canDoubleJump = true;
        onAnyPlatform = true;
      }
    }

    if (!onAnyPlatform) {
      this.vy += gravity;
      this.isOnGround = false;
    }

    if (this.x < 0) this.x = 0;
    if (this.x + this.width > canvas.width) this.x = canvas.width - this.width;
    if (this.y + this.height > canvas.height) {
      this.y = canvas.height - this.height;
      this.vy = 0;
      this.isOnGround = true;
    }

    if (this.abilityCooldown > 0) this.abilityCooldown--;
    if (this.abilityActive) {
      this.abilityDuration--;
      if (this.abilityDuration <= 0) {
        this.abilityActive = false;
        this.shield = false;
        this.speedBoost = false;
      }
    }

    this.vx *= 0.85;
    if (Math.abs(this.vx) < 0.1) this.vx = 0;
  }

  draw(ctx) {
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x, this.y, this.width, this.height);
    if (this.isIt) {
      ctx.strokeStyle = 'gold';
      ctx.lineWidth = 4;
      ctx.strokeRect(this.x - 3, this.y - 3, this.width + 6, this.height + 6);
    }
    if (this.shield) {
      ctx.strokeStyle = 'cyan';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(this.x + this.width/2, this.y + this.height/2, this.width, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}

const players = [
  new Player('red', 100, { left: 'a', right: 'd', jump: 'w', ability: 's' }, 'dash'),
  new Player('green', 300, { left: 'j', right: 'l', jump: 'i', ability: 'k' }, 'shield'),
  new Player('blue', 500, { left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', ability: 'ArrowDown' }, 'speed'),
  new Player('yellow', 700, { left: 'Numpad4', right: 'Numpad6', jump: 'Numpad8', ability: 'Numpad5' }, 'teleport')
];

players[0].isIt = true;

const platforms = [
  new Platform(0, canvas.height - 30, canvas.width, 30),
  new Platform(200, 550, 200, 20),
  new Platform(500, 400, 200, 20),
  new Platform(100, 300, 150, 20),
  new Platform(800, 250, 200, 20),
];

const keysDown = {};
window.addEventListener('keydown', e => keysDown[e.key] = true);
window.addEventListener('keyup', e => keysDown[e.key] = false);

function handleInput() {
  players.forEach(p => {
    if (keysDown[p.keys.left]) p.moveLeft();
    else if (keysDown[p.keys.right]) p.moveRight();
    else p.stopX();

    if (keysDown[p.keys.jump] && !p._jumpPressedLastFrame) p.jump();
    p._jumpPressedLastFrame = keysDown[p.keys.jump];

    if (keysDown[p.keys.ability] && !p._abilityPressedLastFrame) p.useAbility();
    p._abilityPressedLastFrame = keysDown[p.keys.ability];
  });
}

function checkTag() {
  const itPlayer = players.find(p => p.isIt);
  players.forEach(p => {
    if (p !== itPlayer && !p.shield &&
        !(p.x + p.width < itPlayer.x ||
          p.x > itPlayer.x + itPlayer.width ||
          p.y + p.height < itPlayer.y ||
          p.y > itPlayer.y + itPlayer.height)) {
      p.isIt = true;
      itPlayer.isIt = false;
    }
  });
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  platforms.forEach(p => p.draw(ctx));
  players.forEach(p => p.draw(ctx));

  ctx.fillStyle = 'white';
  ctx.font = '20px monospace';
  const it = players.find(p => p.isIt);
  ctx.fillText(`Player ${players.indexOf(it) + 1} is IT!`, 20, 30);
}

function update() {
  handleInput();
  players.forEach(p => p.update(platforms));
  checkTag();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
